#' flows_parse
#'
#' Loads yml workflow files from `flows_directory` and returns a list of data.tables with the workflow data
#'
#' @param flows_directory the directory containing the yml files to load
#'
#' @return named list of workflows as data.tables
#' @importFrom purrr map_chr map2
#' @importFrom checkmate test_character
#' @importFrom config get

flows_parse <- function(flows_directory = config::get("tessiflow.d")) {
  on.schedule <- NULL

  if (is.null(flows_directory)) {
    stop("Please set the tessiflow.d config option to the directory containing the workflow yml files")
  }

  files <- dir(flows_directory, pattern = "*.yml", full.names = TRUE, recursive = TRUE)
  if (length(files) == 0) {
    stop("Please set the tessiflow.d config option to the directory containing the workflow yml files")
  }

  flows <- lapply(files, yaml::read_yaml)

  flow_names <- map_chr(flows, "name")
  if (!test_character(flow_names, any.missing = FALSE, len = length(files), unique = TRUE)) {
    stop("Workflows must have a unique name, which will be used for referring to the workflow.")
  }

  flows <- rbindlist(lapply(flows, flow_to_data_table), fill = TRUE)

  flows[, `:=`(
    status = "Waiting",
    retval = NA_integer_,
    scheduled_runs = lapply(on.schedule, lapply, parse_cron),
    start_time = as.POSIXct(NA),
    end_time = as.POSIXct(NA)
  )]
}

#' flow_to_data_table
#'
#' @param flow single workflow nested list generated by flows_parse
#'
#' @return flow as a data.table
#' @export
#' @importFrom checkmate test_names
#' @importFrom purrr map_chr

flow_to_data_table <- function(flow) {
  allowed_flow_keys <- c("name", "on.schedule.cron", "env\\.[\\w]+")
  allowed_job_keys <- c("name", "needs\\d?", "if", "runs-on")
  allowed_step_keys <- c("name", "env\\.[\\w]+", "if", "run", "shell")

  allowed_keys <- paste0("^", c(
    allowed_flow_keys,
    paste0("jobs\\.[\\w]+\\.", allowed_job_keys),
    paste0("jobs\\.[\\w]+\\.steps\\.", allowed_step_keys)
  ), "$")


  # Fix weird yaml coding that maps "on" to "TRUE"
  if ("TRUE" %in% names(flow)) {
    names(flow)[which(names(flow) == "TRUE")] <- "on"
  }

  keys <- names(unlist(flow))
  flow_name <- flow$name
  if (anyDuplicated(purrr::discard(keys, ~ grepl("steps|cron", ., perl = TRUE)))) {
    stop(paste0(flow_name, ": Duplicated keys found - ", paste(keys[duplicated(keys)], collapse = ", ")))
  }

  if (length(flow$jobs) > 0) {
    for (job in flow$jobs) {
      step_names <- unlist(job)[which(names(unlist(job)) == "steps.name")]
      if (anyDuplicated(step_names)) {
        stop(paste0(flow_name, "/", job$name, ": Duplicated step names found - ", paste(step_names, collapse = ", ")))
      }
    }
  }

  invalid_keys <- grep(paste(allowed_keys, collapse = "|"),
    names(unlist(flow)),
    value = TRUE, invert = TRUE, perl = TRUE
  )

  if (!test_character(names(unlist(flow)), any.missing = FALSE) ||
    length(invalid_keys) > 0) {
    warning(paste0(flow_name, ": Invalid keys found - ", paste(invalid_keys, collapse = ", ")))
  }

  if (length(flow$jobs) == 0) {
    warning(paste0(flow_name, ": No jobs found, nothing to do!"))
  }

  if (length(flow$on$schedule) == 0) {
    warning(paste0(flow_name, ": No schedule found, nothing to do!"))
  }

  flow_data_table <- data.table(
    flow_name = flow_name,
    env = list(flow$env),
    on.schedule = list(unlist(flow$on$schedule, recursive = FALSE)),
    job_name = rep(NA, max(length(flow$jobs), 1))
  )
  # unnest wider
  if (length(flow$jobs) > 0) {
    flow_data_table[, job_name := purrr::map_chr(flow$jobs, "name")]
    job_keys <- unique(purrr::flatten_chr(purrr::map(flow$jobs, names)))
    flow_data_table[, (job_keys) := lapply(job_keys, purrr::map, .x = flow$jobs)]
    flow_data_table[, `:=`(name = NULL)]
  }
}
