#' flows_parse
#'
#' Loads yml workflow files from `flows_directory` and returns a list of data.tables with the workflow data
#'
#' @param flows_directory the directory containing the yml files to load
#' @export
#' @return named list of workflows as data.tables
#' @importFrom purrr map_chr map2
#' @importFrom checkmate test_character
#' @importFrom config get

flows_parse <- function(flows_directory = config::get("tessiflow.d")) {
  on.schedule <- NULL

  if (is.null(flows_directory) ||
    length(files <- dir(flows_directory, pattern = "*.yml", full.names = TRUE)) == 0) {
    stop("Please set the tessiflow.d config option to the directory containing the workflow yml files")
  }

  flows <- lapply(files, yaml::read_yaml) %>% purrr::discard(~ length(.) == 0)

  flow_names <- map_chr(flows, "name")
  if (!test_character(flow_names, any.missing = FALSE, unique = TRUE)) {
    stop("Workflows must have a unique name.")
  }

  flows <- rbindlist(lapply(flows, flow_to_data_table), fill = TRUE)

  flows[, `:=`(
    status = "Waiting",
    retval = NA_integer_,
    scheduled_runs = lapply(on.schedule, lapply, parse_cron),
    start_time = as.POSIXct(NA),
    end_time = as.POSIXct(NA)
  )]

  flows[]
}

#' flow_to_data_table
#'
#' parses a single flow from a yaml file to a data.table
#'
#' @param flow single workflow nested list generated by flows_parse
#'
#' @return flow as a data.table
#' @importFrom checkmate test_names
#' @importFrom purrr map_chr

flow_to_data_table <- function(flow) {
  job_name <- NULL

  allowed_flow_keys <- c("name", "on.schedule.cron", "env\\.[\\w]+")
  allowed_job_keys <- c("name", "needs\\d?", "if", "runs-on")
  allowed_step_keys <- c("name", "env\\.[\\w]+", "if", "run", "shell")

  allowed_keys <- paste0("^", c(
    allowed_flow_keys,
    paste0("jobs\\.[\\w]+\\.", allowed_job_keys),
    paste0("jobs\\.[\\w]+\\.steps\\.", allowed_step_keys)
  ), "$")


  # Fix weird yaml coding that maps "on" to "TRUE"
  if ("TRUE" %in% names(flow)) {
    names(flow)[which(names(flow) == "TRUE")] <- "on"
  }

  keys <- names(unlist(flow))
  flow_name <- flow$name
  if (anyDuplicated(purrr::discard(keys, ~ grepl("steps|cron", ., perl = TRUE)))) {
    stop(paste0(flow_name, ": Duplicated keys found - ", paste(keys[duplicated(keys)], collapse = ", ")))
  }

  if (length(flow$jobs) > 0) {
    for (job in flow$jobs) {
      step_names <- unlist(job)[which(names(unlist(job)) == "steps.name")]
      if (anyDuplicated(step_names)) {
        stop(paste0(flow_name, "/", job$name, ": Duplicated step names found - ", paste(step_names, collapse = ", ")))
      }
    }
  }

  invalid_keys <- grep(paste(allowed_keys, collapse = "|"), keys,
    value = TRUE, invert = TRUE, perl = TRUE
  )

  if (!test_character(names(unlist(flow)), any.missing = FALSE) ||
    length(invalid_keys) > 0) {
    warning(paste0(flow_name, ": Invalid keys found - ", paste(invalid_keys, collapse = ", ")))
  }

  if (length(flow$jobs) == 0) {
    warning(paste0(flow_name, ": No jobs found, nothing to do!"))
  }

  if (length(flow$on$schedule) == 0) {
    warning(paste0(flow_name, ": No schedule found, nothing to do!"))
  }

  if_keys <- grep("\\bif\\b", keys, value = TRUE, perl = TRUE)
  if_parseable <- purrr::map_lgl(unlist(flow)[if_keys], test_parse)
  run_parseable <- list(jobs = map(flow$jobs, ~ list(steps = purrr::map(.$steps, test_parse_run)))) %>% unlist()
  parseable <- c(if_parseable, run_parseable)
  exprs <- c(unlist(flow)[if_keys], unlist(map(flow$jobs, "steps"), recursive = FALSE))

  if (!all(parseable)) {
    stop(paste(c(
      "Statement(s)", paste0(
        names(parseable[!parseable]),
        " : ",
        exprs[!parseable],
        ", "
      ),
      "in", flow_name, "not parseable."
    ), collapse = " "))
  }

  flow_data_table <- data.table(
    flow_name = flow_name,
    env = list(flow$env),
    on.schedule = list(unlist(flow$on$schedule, recursive = FALSE)),
    job_name = rep(NA, max(length(flow$jobs), 1))
  )
  # unnest wider
  if (length(flow$jobs) > 0) {
    flow_data_table[, job_name := purrr::map_chr(flow$jobs, "name")]
    job_keys <- unique(purrr::flatten_chr(purrr::map(flow$jobs, names)))
    flow_data_table[, (job_keys) := lapply(job_keys, purrr::map, .x = flow$jobs)]
    flow_data_table[, `:=`(name = NULL)]
  }

  flow_data_table
}


#' test_parse
#'
#' tests if it's possible to parse the expression string, throws an error if it's not
#'
#' @param expr_string expression as a deparsed string
#'
#' @return TRUE if expr_string is parseable
#' @importFrom checkmate assert_character
#' @importFrom rlang parse_expr
test_parse <- function(expr_string) {
  assert_character(expr_string, max.len = 1, null.ok = TRUE)

  if (length(expr_string) == 0) {
    return(TRUE)
  }

  ret <- tryCatch(parse_expr(as.character(expr_string)),
    error = function(e) {
      return(e)
    }
  )

  !"error" %in% class(ret)
}

#' test_parse_run
#'
#' tests if it's possible to parse the step run statement, throws an error if it's not
#'
#' @param step list of the step object, with keys `if`, `env`, `run`, and `shell`
#'
#' @return TRUE if step is parseable
#' @importFrom checkmate assert_character
#' @importFrom rlang parse_expr
test_parse_run <- function(step) {
  assert_list(step)

  if (length(step) == 0) {
    return(TRUE)
  }

  ret <- tryCatch(job_make_remote_expr(
    run_expr = as.character(step$run),
    env_vars = step$env,
    if_expr = as.character(step$`if`),
    shell = as.character(step$shell)
  ),
  error = function(e) {
    return(e)
  }
  )

  !"error" %in% class(ret)
}
