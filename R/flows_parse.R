#' flows_parse
#'
#' Loads yml workflow files from `flows_directory` and returns a list of data.tables with the workflow data
#'
#' @param flows_directory the directory containing the yml files to load
#' @export
#' @return named list of workflows as data.tables
#' @importFrom purrr map_chr map2
#' @importFrom checkmate test_character

flows_parse <- function(flows_directory = config::get("tessiflow.d")) {
  on.schedule <- NULL

  if (is.null(flows_directory) ||
    length(files <- dir(flows_directory, pattern = "*.yml", full.names = TRUE)) == 0) {
    stop("Please set the tessiflow.d configuration option to the directory containing the workflow yml files")
  }

  flows <- lapply(files, yaml::read_yaml) %>% purrr::discard(~ length(.) == 0)

  flow_names <- map_chr(flows, "name")
  if (!test_character(flow_names, any.missing = FALSE, unique = TRUE)) {
    stop("Workflows must have a unique name.")
  }

  flows <- rbindlist(lapply(flows, flow_to_data_table), fill = TRUE)

  flows[, `:=`(
    status = "Waiting",
    retval = NA_integer_,
    scheduled_runs = lapply(on.schedule, lapply, parse_cron),
    start_time = as.POSIXct(NA),
    end_time = as.POSIXct(NA)
  )]

  flows[]
}

#' flows_auto_refresh
#' 
#' Update flows data.table with new data from yml flows if they have changed since the last load
#' @param flows_directory directory containing the yml files to load
#' @return updated data.table
#' @importFrom lubridate now
flows_auto_refresh <- function(flows_directory = config::get("tessiflow.d")) {
  
  if(is.null(tessiflow$flows) || is.null(tessiflow$flows_refresh_time)) {
    message(paste("Loading flows from",flows_directory))
    tessiflow$flows <- flows_parse(flows_directory)
    tessiflow$flows_refresh_time <- now()
  } else if(any(file.mtime(dir(config::get("tessiflow.d"),full.names = T)) > 
                tessiflow$flows_refresh_time)) {
    message(paste("Refreshing flows from",flows_directory))
    flows_refresh(flows_directory) 
    tessiflow$flows_refresh_time <- now()
  }
  
}

#' flows_refresh
#'
#' Update flows data.table with new data from yml flows
#' @param ... extra arguments passed on to `flows_parse`
#' @return updated data.table
#' @importFrom dplyr anti_join
flows_refresh <- function(...) {
  flows <- flows_parse(...)
  
  new_flows <- anti_join(flows, tessiflow$flows, by = c("flow_name", "job_name"))
  
  update_columns <- intersect(
    c("env", "on.schedule", "runs-on", "steps", "needs", "if", "scheduled_runs", "timeout-minutes"),
    colnames(flows)
  )
  
  tessiflow$flows <- rbindlist(list(
    tessiflow$flows[flows, (update_columns) := mget(paste0("i.", update_columns)),
                    on = c("flow_name", "job_name")
    ],
    new_flows
  ),
  fill = TRUE
  )
}

#' flow_to_data_table
#'
#' parses a single flow from a yml file to a data.table
#'
#' @param flow single workflow nested list generated by flows_parse
#'
#' @return flow as a data.table
#' @importFrom checkmate test_names
#' @importFrom purrr map_chr

flow_to_data_table <- function(flow) {
  job_name <- NULL

  allowed_flow_keys <- c("name", "on.schedule.cron", "env\\.[\\w]+")
  allowed_job_keys <- c("name", "needs\\d?", "if", "runs-on", "timeout-minutes")
  allowed_step_keys <- c("name", "env\\.[\\w]+", "if", "run", "shell")

  allowed_keys <- paste0("^", c(
    allowed_flow_keys,
    paste0("jobs\\.[\\w]+\\.", allowed_job_keys),
    paste0("jobs\\.[\\w]+\\.steps\\.", allowed_step_keys)
  ), "$")


  # Fix weird yml coding that maps "on" to "TRUE"
  if ("TRUE" %in% names(flow)) {
    names(flow)[which(names(flow) == "TRUE")] <- "on"
  }

  keys <- names(unlist(flow))
  flow_name <- flow$name
  if (anyDuplicated(purrr::discard(keys, ~ grepl("steps|cron", ., perl = TRUE)))) {
    stop(paste0(flow_name, ": Duplicated keys found - ", paste(keys[duplicated(keys)], collapse = ", ")))
  }

  if (length(flow$jobs) > 0) {
    for (job in flow$jobs) {
      step_names <- unlist(job)[which(names(unlist(job)) == "steps.name")]
      if (anyDuplicated(step_names)) {
        stop(paste0(flow_name, "/", job$name, ": Duplicated step names found - ", paste(step_names, collapse = ", ")))
      }
    }
  }

  invalid_keys <- grep(paste(allowed_keys, collapse = "|"), keys,
    value = TRUE, invert = TRUE, perl = TRUE
  )

  if (!test_character(names(unlist(flow)), any.missing = FALSE) ||
    length(invalid_keys) > 0) {
    warning(paste0(flow_name, ": Invalid keys found - ", paste(invalid_keys, collapse = ", ")))
  }

  if (length(flow$jobs) == 0) {
    warning(paste0(flow_name, ": No jobs found, nothing to do!"))
  }

  if (length(flow$on$schedule) == 0) {
    warning(paste0(flow_name, ": No schedule found, nothing to do!"))
  }

  if_keys <- grep("\\bif\\b", keys, value = TRUE, perl = TRUE)
  if_parseable <- purrr::map_lgl(unlist(flow)[if_keys], test_parse)
  run_parseable <- list(jobs = map(flow$jobs, ~ list(steps = purrr::map(.$steps, test_parse_run)))) %>% unlist()
  parseable <- c(if_parseable, run_parseable)
  exprs <- c(unlist(flow)[if_keys], unlist(map(flow$jobs, "steps"), recursive = FALSE))

  if (!all(parseable)) {
    stop(paste(c(
      "Statement(s)", paste0(
        names(parseable[!parseable]),
        " : ",
        exprs[!parseable],
        ", "
      ),
      "in", flow_name, "not parseable."
    ), collapse = " "))
  }

  job_names <- if(length(flow$jobs) == 0) { NA_character_ } else { map_chr(flow$jobs, "name") }
  
  flow_data_table <- data.table(
    # return at least one row
    flow_name = flow_name,
    job_name = job_names,
    env = list(flow$env),
    # simplify weirdly nested structure to simple list column
    on.schedule = list(unlist(flow$on$schedule,recursive=F))
  )
  
  job_keys <- c("needs", "if", "runs-on", "timeout-minutes", "steps")
  
  for(col in job_keys) {
    flow_data_table[, (col) := lapply(flow$jobs, `[[`, col)]
  }
  
  flow_data_table
}


#' test_parse
#'
#' tests if it's possible to parse the expression string, throws an error if it's not
#'
#' @param expr_string expression as a deparsed string
#'
#' @return TRUE if expr_string is parseable
#' @importFrom checkmate assert_character
#' @importFrom rlang parse_expr
test_parse <- function(expr_string) {
  assert_character(expr_string, max.len = 1, null.ok = TRUE)

  if (length(expr_string) == 0) {
    return(TRUE)
  }

  ret <- tryCatch(parse_expr(as.character(expr_string)),
    error = function(e) {
      return(e)
    }
  )

  !"error" %in% class(ret)
}

#' test_parse_run
#'
#' tests if it's possible to parse the step run statement, throws an error if it's not
#'
#' @param step list of the step object, with keys `if`, `env`, `run`, and `shell`
#'
#' @return TRUE if step is parseable
#' @importFrom checkmate assert_character
#' @importFrom rlang parse_expr
test_parse_run <- function(step) {
  assert_list(step)

  if (length(step) == 0) {
    return(TRUE)
  }

  ret <- tryCatch(job_make_remote_fun(
    run_expr = as.character(step$run),
    env_vars = step$env,
    if_expr = as.character(step$`if`),
    shell = as.character(step$shell)
  ),
  error = function(e) {
    return(e)
  }
  )

  !"error" %in% class(ret)
}
